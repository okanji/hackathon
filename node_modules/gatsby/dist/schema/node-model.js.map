{"version":3,"sources":["../../src/schema/node-model.js"],"names":["_","require","isAbstractType","GraphQLOutputType","GraphQLUnionType","invariant","LocalNodeModel","constructor","schema","nodeStore","createPageDependency","path","getNodeById","args","pageDependencies","id","type","node","result","nodeTypeNames","toNodeTypeNames","includes","internal","trackPageDependencies","getNodesByIds","ids","nodes","Array","isArray","map","filter","Boolean","length","getAllNodes","getNodes","reduce","acc","typeName","concat","getNodesByType","runQuery","query","firstOnly","gqlType","getType","queryResult","queryArgs","getTypes","findRootNodeAncestor","obj","predicate","isPlainObject","getNode","gqlTypeName","possibleTypes","getPossibleTypes","getInterfaces","some","iface","name","connectionType","connection","nodeId","module","exports"],"mappings":"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","sourcesContent":["// @flow\n\nconst _ = require(`lodash`)\nconst {\n  isAbstractType,\n  GraphQLOutputType,\n  GraphQLUnionType,\n} = require(`graphql`)\nconst invariant = require(`invariant`)\n\ntype IDOrNode = string | { id: string }\ntype TypeOrTypeName = string | GraphQLOutputType\n\n/**\n * Optional page dependency information.\n *\n * @typedef {Object} PageDependencies\n * @property {string} path The path of the page that depends on the retrieved nodes' data\n * @property {string} [connectionType] Mark this dependency as a connection\n */\ninterface PageDependencies {\n  path: string;\n  connectionType?: string;\n}\n\ninterface QueryArguments {\n  type: TypeOrTypeName;\n  query: { filter: Object, sort?: Object, skip?: number, limit?: number };\n  firstOnly?: boolean;\n}\n\nexport interface NodeModel {\n  getNodeById(\n    { id: IDOrNode, type?: TypeOrTypeName },\n    pageDependencies?: PageDependencies\n  ): any | null;\n  getNodesByIds(\n    { ids: Array<IDOrNode>, type?: TypeOrTypeName },\n    pageDependencies?: PageDependencies\n  ): Array<any>;\n  getAllNodes(\n    { type?: TypeOrTypeName },\n    pageDependencies?: PageDependencies\n  ): Array<any>;\n  runQuery(\n    args: QueryArguments,\n    pageDependencies?: PageDependencies\n  ): Promise<any>;\n  getTypes(): Array<string>;\n}\n\nclass LocalNodeModel {\n  constructor({ schema, nodeStore, createPageDependency, path }) {\n    this.schema = schema\n    this.nodeStore = nodeStore\n    this.createPageDependency = createPageDependency\n    this.path = path\n  }\n\n  /**\n   * Get a node from the store by ID and optional type.\n   *\n   * @param {Object} args\n   * @param {string} args.id ID of the requested node\n   * @param {(string|GraphQLOutputType)} [args.type] Optional type of the node\n   * @param {PageDependencies} [pageDependencies]\n   * @returns {(Node|null)}\n   */\n  getNodeById(args, pageDependencies) {\n    const { id, type } = args || {}\n\n    const node = getNodeById(this.nodeStore, id)\n\n    let result\n    if (!node) {\n      result = null\n    } else if (!type) {\n      result = node\n    } else {\n      const nodeTypeNames = toNodeTypeNames(this.schema, type)\n      result = nodeTypeNames.includes(node.internal.type) ? node : null\n    }\n\n    return trackPageDependencies(\n      result,\n      { path: this.path, ...pageDependencies },\n      this.createPageDependency\n    )\n  }\n\n  /**\n   * Get nodes from the store by IDs and optional type.\n   *\n   * @param {Object} args\n   * @param {string[]} args.ids IDs of the requested nodes\n   * @param {(string|GraphQLOutputType)} [args.type] Optional type of the nodes\n   * @param {PageDependencies} [pageDependencies]\n   * @returns {Node[]}\n   */\n  getNodesByIds(args, pageDependencies) {\n    const { ids, type } = args || {}\n\n    const nodes = Array.isArray(ids)\n      ? ids.map(id => getNodeById(this.nodeStore, id)).filter(Boolean)\n      : []\n\n    let result\n    if (!nodes.length || !type) {\n      result = nodes\n    } else {\n      const nodeTypeNames = toNodeTypeNames(this.schema, type)\n      result = nodes.filter(node => nodeTypeNames.includes(node.internal.type))\n    }\n\n    return trackPageDependencies(\n      result,\n      { path: this.path, ...pageDependencies },\n      this.createPageDependency\n    )\n  }\n\n  /**\n   * Get all nodes in the store, or all nodes of a specified type.\n   *\n   * @param {Object} args\n   * @param {(string|GraphQLOutputType)} [args.type] Optional type of the nodes\n   * @param {PageDependencies} [pageDependencies]\n   * @returns {Node[]}\n   */\n  getAllNodes(args, pageDependencies) {\n    const { type } = args || {}\n\n    let result\n    if (!type) {\n      result = this.nodeStore.getNodes()\n    } else {\n      const nodeTypeNames = toNodeTypeNames(this.schema, type)\n      const nodes = nodeTypeNames.reduce(\n        (acc, typeName) => acc.concat(this.nodeStore.getNodesByType(typeName)),\n        []\n      )\n      result = nodes.filter(Boolean)\n    }\n\n    return trackPageDependencies(\n      result,\n      { path: this.path, ...pageDependencies },\n      this.createPageDependency\n    )\n  }\n\n  /**\n   * Get nodes of a type matching the specified query.\n   *\n   * @param {Object} args\n   * @param {Object} args.query Query arguments (`filter`, `sort`, `limit`, `skip`)\n   * @param {(string|GraphQLOutputType)} args.type Type\n   * @param {boolean} [args.firstOnly] If true, return only first match\n   * @param {PageDependencies} [pageDependencies]\n   * @returns {Promise<Node[]>}\n   */\n  async runQuery(args, pageDependencies) {\n    const { query, firstOnly, type } = args || {}\n\n    // We don't support querying union types (yet?), because the combined types\n    // need not have any fields in common.\n    const gqlType = typeof type === `string` ? this.schema.getType(type) : type\n    invariant(\n      !(gqlType instanceof GraphQLUnionType),\n      `Querying GraphQLUnion types is not supported.`\n    )\n\n    // We provide nodes in case of abstract types, because `run-sift` should\n    // only need to know about node types in the store.\n    let nodes\n    const nodeTypeNames = toNodeTypeNames(this.schema, gqlType)\n    if (nodeTypeNames.length > 1) {\n      nodes = nodeTypeNames.reduce(\n        (acc, typeName) => acc.concat(this.nodeStore.getNodesByType(typeName)),\n        []\n      )\n    }\n\n    const queryResult = await this.nodeStore.runQuery({\n      queryArgs: query,\n      firstOnly,\n      gqlType,\n      nodes,\n    })\n\n    let result = queryResult\n    if (args.firstOnly) {\n      if (result && result.length > 0) {\n        result = result[0]\n      } else {\n        result = null\n      }\n    }\n\n    return trackPageDependencies(\n      result,\n      { path: this.path, ...pageDependencies },\n      this.createPageDependency\n    )\n  }\n\n  /**\n   * Get the names of all node types in the store.\n   *\n   * @returns {string[]}\n   */\n  getTypes() {\n    return this.nodeStore.getTypes()\n  }\n\n  /**\n   * Get the root ancestor node for an object's parent node, or its first\n   * ancestor matching a specified condition.\n   *\n   * @param {(Object|Array)} obj An object belonging to a Node, or a Node object\n   * @param {Function} [predicate] Optional condition to match\n   * @returns {(Node|null)}\n   */\n  findRootNodeAncestor(obj, predicate) {\n    return this.nodeStore.findRootNodeAncestor(obj, predicate)\n  }\n}\n\nconst getNodeById = (nodeStore, id) => {\n  // This is for cases when the `id` has already been resolved\n  // to a full Node for the input filter, and is also in the selection\n  // set. E.g. `{ foo(parent: { id: { eq: 1 } } ) { parent { id } } }`.\n  if (_.isPlainObject(id) && id.id) {\n    return id\n  }\n  return id != null ? nodeStore.getNode(id) : null\n}\n\nconst toNodeTypeNames = (schema, gqlTypeName) => {\n  const gqlType =\n    typeof gqlTypeName === `string` ? schema.getType(gqlTypeName) : gqlTypeName\n\n  if (!gqlType) return []\n\n  const possibleTypes = isAbstractType(gqlType)\n    ? schema.getPossibleTypes(gqlType)\n    : [gqlType]\n\n  return possibleTypes\n    .filter(type => type.getInterfaces().some(iface => iface.name === `Node`))\n    .map(type => type.name)\n}\n\nconst trackPageDependencies = (\n  result,\n  pageDependencies,\n  createPageDependency\n) => {\n  const { path, connectionType } = pageDependencies\n  if (path) {\n    if (connectionType) {\n      createPageDependency({ path, connection: connectionType })\n    } else {\n      const nodes = Array.isArray(result) ? result : [result]\n      nodes\n        .filter(Boolean)\n        .map(node => createPageDependency({ path, nodeId: node.id }))\n    }\n  }\n\n  return result\n}\n\nmodule.exports = {\n  LocalNodeModel,\n}\n"],"file":"node-model.js"}